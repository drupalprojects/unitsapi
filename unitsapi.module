<?php // $Id$

/**
 * @file
 * Provides a variety of measurement unit conversions.
 */

/**
 * The API call for all unit conversions.
 *
 * @param $value
 *   A number containing the value of the measurement.
 * @param $from
 *   A string containing the name of the measurement to convert from.
 * @param $to
 *   A string containing the name of the measurement to convert to.
 * @param $details
 *   A boolean value.  TRUE returns an array with details about the conversion.  FALSE returns
 *   simply the converted value.  Default is FALSE.
 * @return
 *   A float containing the result of the conversion. FALSE if an error occured.
 */
function unitsapi_convert($value, $from, $to, $details = FALSE) {

  $units = module_invoke_all('unitsapi');

  // Only accept numeric values.
  if (!is_numeric($value)) {
    drupal_set_message(t('Unit conversion value must be numeric.'), 'error');
    return FALSE;
  }

  // Check to see if the unit key was found in the array.
  if (!isset($units[$from]) || !isset($units[$to])) {
    drupal_set_message(t('Units API cannot find the specified measurement units.'), 'error');
    return FALSE;
  }

  // Only convert with like kinds
  if ($units[$from]['kind'] != $units[$to]['kind']) {
    drupal_set_message(t('Units API cannot convert between different kinds of measurement units.'), 'error');
    return FALSE;
  }

  // Execute the conversion factors differently based on the kind.  For example, temperature needs to be executed differently.
  switch ($units[$from]['kind']) {
    case 'temperature':
        $result = _unitsapi_convert_temperature($value, $units[$to]['factor'][$from]);
      break;
    default:
      $from_si = $units[$from]['factor'];
      $to_si = $units[$to]['factor'];
      $from_convert = $value * $from_si;
      $result = $from_convert / $to_si;
  }

  // Round to the 6 spaces after the decimal.
  $result = round($result, 6);

  $return = array();
  if ($details) {
    $return['result'] = $result;
    $return['from'] = $value == 1 ? t($units[$from]['singular']) : t($units[$from]['plural']);
    $return['to'] = $result == 1 ? t($units[$to]['singular']) : t($units[$to]['plural']);
  }
  else {
    $return = $result;
  }

  return $return;
}

/**
 * Implementation of hook_unitsapi().
 */
function unitsapi_unitsapi() {
  $cache = cache_get('unitsapi_data');
  if (empty($cache->data)) {
    unitsapi_xml_cache();
    $cache = cache_get('unitsapi_data');
  }

  $units = $cache->data;
  return $units;
}

/**
 * Loads units.xml and saves it in the cache as a serialized array.
 *
 * @return
 *   TRUE if the cache was successful. FALSE if an error occured.
 */
function unitsapi_xml_cache() {

  $file = url(drupal_get_path('module', 'unitsapi'), array('absolute' => TRUE)) .'/units.xml';

  // Load the XML file
  if (!function_exists('simplexml_load_file')) {
    drupal_set_message(t('SimpleXML not found.  PHP 5 is required for Units API.'), 'error');
    return FALSE;
  }
  elseif (empty($file)) {
    drupal_set_message(t('The specified Units XML file is empty.'), 'error');
    return FALSE;
  }
  elseif (!$xml = simplexml_load_file($file)) {
    drupal_set_message(t('The Units API XML file could not be loaded by SimpleXML.'), 'error');
    return FALSE;
  }


  // Loop the XML file.  It is often easier to force the type of the SimpleXML object to an array.
  foreach ((array) $xml as $kind => $units) {

    foreach ($units->unit as $unit) {

      $unitarray = (array) $unit;

      // If this unit has multiple factors, set them in $unitsarray according to their kind
      if (isset($unit->factors)) {
        unset($unitarray['factors']);
        foreach ($unit->factors->factor as $factor) {
          $factor = (array) $factor;

          switch ($kind) {
            case 'temperature':
                $unitarray['factor'][$factor['@attributes']['from']] = $factor[0];
              break;
          }
        }
      }

      $units_cache[$unitarray['key']] = array(
        'singular' => $unitarray['singular'],
        'plural' => $unitarray['plural'],
        'symbol' => $unitarray['symbol'],
        'factor' => _unitsapi_factor_set($unitarray['factor']),
        'kind' => $kind,
      );

    }
  }

  cache_set('unitsapi_data', $units_cache);
  return TRUE;
}


/**
 * Helper function to format the conversion factor.
 *
 * @param $si
 *   A string or array containing the conversion factor equation.
 * @return
 *   A string or array that contains equations that are formatted for execution.
 */
function _unitsapi_factor_set($si) {

  $si = str_replace(' ', '', $si);
  $si = str_replace(array('—', '−', '–'), '-', $si);

  return $si;
}

/**
 * Executes the temperature conversion equation.
 *
 * @param $value
 *   A number containing the value of the temperature.
 * @param $factor
 *   A string containing the conversion equation.
 * @return
 *   A float containing the result of the conversion. FALSE if an error occured.
 */
function _unitsapi_convert_temperature($value, $factor) {

  // Security note: Execute a variety of checks to make sure the equation is not something mischievous
  $equation = str_replace(array('t/°C', 't/°F', 'T/K'), $value, $factor);
  $equation = preg_replace("/[^0-9+\-.*\/()%]/", "", $equation);
  $equation = preg_replace("/([+-])([0-9]+)(%)/", "*(1\$1.\$2)", $equation);
  $equation = preg_replace("/([0-9]+)(%)/", ".\$1", $equation);

  if ($equation == "") {
    $return = FALSE;
  }
  else {
    eval("\$return=". $equation .";");
  }
  return $return;
}
